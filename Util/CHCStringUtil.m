/*! @class @abstract 字符串操作类 */#import "CHCStringUtil.h"#import "HCLog.h"#include <sys/socket.h>#include <sys/sysctl.h>#include <net/if.h>#include <net/if_dl.h>#import <CommonCrypto/CommonDigest.h>#import <QuartzCore/QuartzCore.h>#import "sys/utsname.h"@implementation CHCStringUtil//比较两个c字符串+ (BOOL)compareCString:(char*)aCstr1 Cstr2:(char*)aCstr2{  if(strcmp(aCstr1, aCstr2) == 0)  {    return YES;  }  else  {    return NO;  }}//判断两者内容是否相同+ (BOOL)compareStringIfOrderedSame:(NSString *)aStr1 Str2:(NSString *)aStr2{  BOOL result = [aStr1 compare:aStr2] == NSOrderedSame;  return result;}//判断两对象值的大小(按字母顺序进行比较，astring02大于astring01为真)+ (BOOL)compareStringIfOrderedAscending:(NSString *)aStr1 Str2:(NSString *)aStr2{  BOOL result = [aStr1 compare:aStr2] == NSOrderedAscending;  return result;}//不考虑大 小写比较字符串 判断两对象值的大小(按字母顺序进行比较，astring02小于astring01为真+ (BOOL)compareStringIfOrderedSameCaseInsensitive:(NSString *)aStr1 Str2:(NSString *)aStr2{  BOOL result = [aStr1 caseInsensitiveCompare:aStr2] == NSOrderedSame;  return result;}//改变字符串的大小写//大写+ (NSString*)uppercaseString:(NSString *)aStr{  NSString *str = nil;  if (!aStr)  {    str = nil;  }  else  {    str = [aStr uppercaseString];  }  return str;}//小写+ (NSString*)lowercaseString:(NSString *)aStr{  NSString *str = nil;  if (!aStr)  {    str =  nil;  }  else  {    str = [aStr lowercaseString];  }  return str;}//首字母大小+ (NSString*)capitalizedString:(NSString *)aStr{  NSString *str = nil;  if (!aStr)  {    str =  nil;  }  else  {    str = [aStr capitalizedString];  }  return str;}//截取到index+ (NSString*)getStringToIndex:(NSInteger)aIndex fromString:(NSString *)aFromString{  NSString *str = nil;  if (!aFromString && aIndex < 0)  {    str =  nil;  }  else  {    str = [aFromString substringToIndex:aIndex];  }  return str;}//URL encode+ (NSString*)urlEncodedString:(NSString *)string{  NSString * encodedString = (__bridge_transfer  NSString*) CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault, (__bridge CFStringRef)string, NULL, (__bridge CFStringRef)@"!*'();:@&=+$,/?%#[]", kCFStringEncodingUTF8 );    return encodedString;}//从index开始截取+ (NSString*)getStringFromIndex:(NSInteger)aIndex fromString:(NSString *)aFromString{  NSString *str = nil;  if (!aFromString && aIndex < 0)  {    str =  nil;  }  else  {    str = [aFromString substringFromIndex:aIndex];  }    return str;}//从index1截取到index2+ (NSString*)getStringFromIndex:(NSInteger)aIndex1 Index2:(NSInteger)aIndex2                     fromString:(NSString *)aFromString{  NSString *str = nil;  if ((!aFromString)||(aIndex1 < 0)||(aIndex2 < 0))  {    str = nil;  }  else  {    str = [aFromString substringWithRange:NSMakeRange(aIndex1, aIndex2)];  }  return str;}#pragma mark 字符串长度处理  字符串长度超过15截取+ (NSString *)calculateStringAndCutoutString :(NSString *)aTextString{  // 这个方法是截取8个字    NSString *resultStr = nil;    if(aTextString && [aTextString length] > 15 )  {    NSString *stringLengthOf16 = [CHCStringUtil calculateStringAndCutoutString:aTextString withMaxLen:15];    resultStr = [NSString stringWithFormat:@"%@  %@",stringLengthOf16,@"..."];  }  return resultStr;}#pragma mark 根据长度截取字符串+ (NSUInteger)calculateStringLength :(NSString *)aTextString{  // 0x20 0x7E  float textStringLength = 0;  for (int i = 0; i < [aTextString length]; i++)  {    float stringLength = 0;    int a = [aTextString characterAtIndex:i];    if (a == 8198)    {      stringLength = 0;    }    else if (a >= 0x20 && a <= 0x7E)    {      stringLength = 0.5;    }    else    {      stringLength = 1.0;    }    textStringLength += stringLength;  }  return ceilf(textStringLength);}+ (float)calculateStringFloatLength :(NSString *)aTextString{  // 0x20 0x7E  float textStringLength = 0;  for (int i = 0; i < [aTextString length]; i++)  {    float stringLength = 0;    int a = [aTextString characterAtIndex:i];    if (a == 8198)    {      stringLength = 0;    }    else if (a >= 0x20 && a <= 0x7E)    {      stringLength = 0.5;    }    else    {      stringLength = 1.0;    }    textStringLength += stringLength;  }  return textStringLength;}+ (NSString *)calculateStringAndCutoutString :(NSString *)aTextString                                   withMaxLen:(NSInteger)aMaxLength{  float textStringLength = 0;  NSString *retString = aTextString;  for (int i = 0; i < [aTextString length]; i++)  {    float stringLength = 0;    int a = [aTextString characterAtIndex:i];    if (a >= 0x20 && a <= 0x7E)      stringLength = 0.5;    else      stringLength = 1.0;    textStringLength += stringLength;    if (textStringLength > aMaxLength)    {      retString = [aTextString substringWithRange:NSMakeRange(0, i)];      break;    }  }  return retString;}+ (NSString*)insertString:(NSInteger)aIndex  digString:(NSString *)aDigstring               fromString:(NSString *)aFromString;{  NSString *rtnString = nil;  if ((!aDigstring)||(!aFromString)||(aIndex < 0))  {    return nil;  }    NSString *retString = aFromString;  NSMutableString *mretString = [[NSString stringWithString:retString] mutableCopy];  [mretString insertString:aDigstring atIndex:aIndex];  rtnString = [NSString stringWithString:mretString];  return rtnString;} #pragma mark MD5用于字符串 + (NSString *)md5ToString:(NSString *)aFromString { const char *cStr = [aFromString UTF8String]; unsigned char result[16]; CC_MD5( cStr, (unsigned int)strlen(cStr), result ); return [NSString stringWithFormat: @"%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X", result[0], result[1], result[2], result[3], result[4], result[5], result[6], result[7], result[8], result[9], result[10], result[11], result[12], result[13], result[14], result[15]]; }/* + (NSString *)md5ToString:(NSString *)aFromString type:(TMD5Length)aType { const char *cStr = [aFromString UTF8String];  NSString *aStr = [CHCStringUtil md5ToCStr:cStr dataLen:strlen(cStr) type:aType];  return aStr; } + (NSString *)md5ToData:(NSData *)aData { const char *cStr = [aData bytes]; unsigned char result[16]; CC_MD5( cStr, [aData length], result ); return [NSString stringWithFormat: @"%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X", result[0], result[1], result[2], result[3], result[4], result[5], result[6], result[7], result[8], result[9], result[10], result[11], result[12], result[13], result[14], result[15]]; }  + (NSString *)md5ToData:(NSData *)aData type:(TMD5Length)aType { const char *cStr = [aData bytes];  NSString *aStr = [CHCStringUtil md5ToCStr:cStr dataLen:[aData length] type:aType];  return aStr; } + (NSString *)md5ToCStr:(const char*)aCStr dataLen:(CC_LONG)aLength type:(TMD5Length)aType { unsigned char result[16]; CC_MD5( aCStr, aLength, result );  NSString *aStr = nil;  switch (aType) { case EMD5LengthDefault: aStr = nil; break;  case EMD5Length16: aStr = [NSString  stringWithFormat: @"%02X%02X%02X%02X%02X%02X%02X%02X", result[4], result[5], result[6], result[7], result[8], result[9], result[10], result[11]]; break;  case EMD5Length32: aStr = [NSString  stringWithFormat: @"%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X", result[0], result[1], result[2], result[3], result[4], result[5], result[6], result[7], result[8], result[9], result[10], result[11], result[12], result[13], result[14], result[15]]; break;  default: aStr = nil; break; } return aStr; } */+ (NSString *)dateToString:(NSData *)aData{  return [[NSString alloc] initWithData:aData encoding:NSUTF8StringEncoding] ;}+ (NSData *)stringToData:(NSString *)aFromString{  if (!aFromString)  {    return nil;  }  return [aFromString dataUsingEncoding: NSUTF8StringEncoding];}+ (Byte *)dataToByte:(NSData *)aData{  return (Byte *)[aData bytes];}/////数组+ (NSMutableArray *) removeObjectAtIndex:(unsigned)aIndex fromString:(NSMutableArray *)aFromString;{  NSMutableArray *array = [NSMutableArray arrayWithObjects:aFromString,nil];  [array removeObjectAtIndex:aIndex];    return  array;}//校验url+ (BOOL) validateURL:(NSString *)aURl{  NSRegularExpression *regularexpression = [[NSRegularExpression alloc] initWithPattern:@"\\b[a-zA-Z0-9\\-.]+(?::(\\d+))?(?:(?:/[a-zA-Z0-9\\-._?,'+\\&%$=~*!():@\\\\]*)+)?"                                                                                options:NSRegularExpressionCaseInsensitive                                                                                  error:nil];  NSUInteger numberofMatch = [regularexpression numberOfMatchesInString:aURl                                                                options:NSMatchingReportProgress                                                                  range:NSMakeRange(0, aURl.length)];  if(numberofMatch > 0)  {    HCLog(@"%@ isNumbericString: YES", aURl);    return YES;  }  HCLog(@"%@ isNumbericString: NO", aURl);  return NO;}#pragma mark 获取字符串字体在界面上显示的长度+ (CGFloat) getWidthOfString:(NSString *)aString withFont:(UIFont *)aFont{  CGSize detailSize = [aString boundingRectWithSize:CGSizeMake(MAXFLOAT, 30)                                            options:                       NSStringDrawingTruncatesLastVisibleLine                       |NSStringDrawingUsesLineFragmentOrigin                       |NSStringDrawingUsesFontLeading                       |NSStringDrawingUsesDeviceMetrics                                         attributes:@{NSFontAttributeName:aFont}                                            context:nil].size;  return detailSize.width;}+ (NSString *)getSubStringOfString:(NSString *)aString                          withFont:(UIFont *)aFont                         withWidth:(CGFloat)aWidth{  CGSize aStringSize = [aString boundingRectWithSize:CGSizeMake(MAXFLOAT, 30)                                             options:                        NSStringDrawingTruncatesLastVisibleLine                        |NSStringDrawingUsesLineFragmentOrigin                        |NSStringDrawingUsesFontLeading                        |NSStringDrawingUsesDeviceMetrics                                          attributes:@{NSFontAttributeName:aFont}                                             context:nil].size;  int i = 0 ;  NSString *subString = aString;  while(aStringSize.width > aWidth)  {    i++;    subString = [aString substringToIndex:([aString length] - i)];    aStringSize = [subString boundingRectWithSize:CGSizeMake(MAXFLOAT, 30)                                          options:                   NSStringDrawingTruncatesLastVisibleLine                   |NSStringDrawingUsesLineFragmentOrigin                   |NSStringDrawingUsesFontLeading                   |NSStringDrawingUsesDeviceMetrics                                       attributes:@{NSFontAttributeName:aFont}                                          context:nil].size;  }  return subString;}/*** 判断是否为数字，如果含有非数字字符返回nil **/+(NSMutableString *)filteNumber:(NSString *) number{  FUNCBEGIN;  NSMutableString *strippedString = [NSMutableString                                     stringWithCapacity:number.length];    NSScanner *scanner = [NSScanner scannerWithString:number];  NSCharacterSet *numbers = [NSCharacterSet                             characterSetWithCharactersInString:@"0123456789"];  //循环验证是否为数字  while ([scanner isAtEnd] == NO)  {    NSString *buffer;    if ([scanner scanCharactersFromSet:numbers intoString:&buffer])    {      [strippedString appendString:buffer];    }    // --------- Add the following to get out of endless loop    else    {      return nil;      //            [scanner setScanLocation:([scanner scanLocation] + 1)];    }    // --------- End of addition  }  FUNCEND;  return strippedString;}//根据给定的分隔符分隔给定的字符串+(NSMutableArray*)divideString:(NSString*)aString                 WithSeparator:(NSString*)aSeparator{  NSMutableArray * divideArray = nil;  if (![aString isKindOfClass:[NSString class]]      ||![aSeparator isKindOfClass:[NSString class]])  {    //传入的参数类型不对    divideArray = nil;  }  else  {    divideArray = [[NSMutableArray alloc] init];    //待查找字符串    NSString * srcStr = aString;    while (YES)    {      //查找分隔符的位置      NSRange range = [srcStr rangeOfString:aSeparator];      if (range.length >0)      {        //找到了        NSString * aDivideStr = [srcStr substringToIndex:range.location];        [divideArray addObject:aDivideStr];        srcStr = [srcStr substringFromIndex:range.location + range.length];      }      else      {        //没有找到        NSString * aDivideStr = srcStr;        [divideArray addObject:aDivideStr];        //退出循环        break;      }    }  }  return divideArray;}#pragma mark 给指定字符串，指定精度加上千分符+(NSString *)addThousandSeparator:(NSString *)inputString digit:(NSUInteger)digit{  NSNumberFormatter *numberFormatter = [[NSNumberFormatter alloc] init];  NSNumber *theNumber = [numberFormatter numberFromString:inputString];  [numberFormatter setNumberStyle:NSNumberFormatterDecimalStyle];  [numberFormatter setMinimumFractionDigits:digit];  [numberFormatter setMaximumFractionDigits:digit];  NSString *resStr = [numberFormatter stringFromNumber:theNumber];  return resStr;}#pragma mark 给指定字符串，指定精度去掉千分符+(NSString *)delThousandSeparator:(NSString *)inputString digit:(NSUInteger)digit{    NSNumberFormatter *numberFormatter = [[NSNumberFormatter alloc] init];  [numberFormatter setNumberStyle:NSNumberFormatterDecimalStyle];  NSNumber *theNumber = [numberFormatter numberFromString:inputString];  [numberFormatter setNumberStyle:NSNumberFormatterNoStyle];  [numberFormatter setMinimumFractionDigits:digit];  [numberFormatter setMaximumFractionDigits:digit];  NSString *resStr = [numberFormatter stringFromNumber:theNumber];  return resStr;}+ (NSString *)timeStringWithDate:(NSString *)aDateString{  NSString * timeString = nil;  NSDateFormatter * dateFormatter = [[NSDateFormatter alloc] init];  NSString * formatterString = @"yyyy-MM-dd HH:mm:ss";  [dateFormatter setDateFormat:formatterString];  NSDate * date = [dateFormatter dateFromString:aDateString];    BOOL isToday = [self isTodayWithDate:date];  BOOL isYesterday = [self isYesterdayWithDate:date];  BOOL isThisYear = [self isThisYearWithDate:date];  if (isToday)  {    formatterString = @"HH:mm";    [dateFormatter setDateFormat:formatterString];    timeString = [NSString stringWithFormat:@"今天 %@", [dateFormatter stringFromDate:date]];  } else if (isYesterday) {    formatterString = @"HH:mm";    [dateFormatter setDateFormat:formatterString];    timeString = [NSString stringWithFormat:@"昨天 %@", [dateFormatter stringFromDate:date]];  } else if (isThisYear) {    formatterString = @"MM-dd HH:mm";    [dateFormatter setDateFormat:formatterString];    timeString = [NSString stringWithFormat:@"%@", [dateFormatter stringFromDate:date]];  } else {    formatterString = @"yyyy-MM-dd HH:mm";    [dateFormatter setDateFormat:formatterString];    timeString = [NSString stringWithFormat:@"%@", [dateFormatter stringFromDate:date]];  }  return timeString;}+ (BOOL)isTodayWithDate:(NSDate *)aDate{  NSCalendar *calendar = [ NSCalendar currentCalendar ];  int unit = NSCalendarUnitDay | NSCalendarUnitMonth |  NSCalendarUnitYear ;  NSDateComponents *nowCmps = [calendar components :unit fromDate :[ NSDate date ]];  NSDateComponents *selfCmps = [calendar components :unit fromDate : aDate ];  //直接分别用当前对象和现在的时间进行比较，比较的属性就是年月日  return (selfCmps. year == nowCmps. year ) && (selfCmps. month == nowCmps. month ) &&  (selfCmps. day == nowCmps. day );}+ (BOOL)isYesterdayWithDate:(NSDate *)aDate{  NSCalendar *calendar = [ NSCalendar currentCalendar ];  int unit = NSCalendarUnitDay | NSCalendarUnitMonth |  NSCalendarUnitYear ;  NSDateComponents *nowCmps = [calendar components :unit fromDate :[ NSDate dateWithTimeIntervalSinceNow:-24 * 60 * 60]];  NSDateComponents *selfCmps = [calendar components :unit fromDate : aDate ];  //直接分别用当前对象和现在的时间进行比较，比较的属性就是年月日  return (selfCmps. year == nowCmps. year ) && (selfCmps. month == nowCmps. month ) &&  (selfCmps. day == nowCmps. day );}+ (BOOL)isThisYearWithDate:(NSDate *)aDate{  NSCalendar *calendar = [NSCalendar currentCalendar];  int unit = NSCalendarUnitYear;  //获取当前的年月日  NSDateComponents  *nowCmps = [calendar  components :unit fromDate :[ NSDate  date ]];  //获得self的年月日  NSDateComponents *selfCmps = [calendar components :unit fromDate : aDate ];  return nowCmps. year == selfCmps. year ;}/** *  判断是否含有emoji表情 * *  @param string 字符串 * *  @return 返回布尔值 */+ (BOOL)stringContainsEmoji:(NSString *)string{  __block BOOL returnValue = NO;    [string enumerateSubstringsInRange:NSMakeRange(0, [string length])                             options:NSStringEnumerationByComposedCharacterSequences                          usingBlock:^(NSString *substring, NSRange substringRange, NSRange enclosingRange, BOOL *stop)   {     const unichar hs = [substring characterAtIndex:0];     if (0xd800 <= hs && hs <= 0xdbff)     {       if (substring.length > 1)       {         const unichar ls = [substring characterAtIndex:1];         const int uc = ((hs - 0xd800) * 0x400) + (ls - 0xdc00) + 0x10000;         if (0x1d000 <= uc && uc <= 0x1f77f)         {           returnValue = YES;         }       }     } else if (substring.length > 1)     {       const unichar ls = [substring characterAtIndex:1];       if (ls == 0x20e3) {         returnValue = YES;       }     } else {       if (0x2100 <= hs && hs <= 0x27ff)       {         returnValue = YES;       } else if (0x2B05 <= hs && hs <= 0x2b07)       {         returnValue = YES;       } else if (0x2934 <= hs && hs <= 0x2935)       {         returnValue = YES;       } else if (0x3297 <= hs && hs <= 0x3299)       {         returnValue = YES;       } else if (hs == 0xa9 || hs == 0xae || hs == 0x303d || hs == 0x3030 || hs == 0x2b55 || hs == 0x2b1c || hs == 0x2b1b || hs == 0x2b50)       {         returnValue = YES;       }     }   }];    return returnValue;}@end